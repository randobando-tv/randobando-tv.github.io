<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>RANDO_AR — MindAR (UI & Events applied)</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

  <!-- MindAR (A-Frame integration) -->
  <!-- CHANGE: usar mindar-image no lugar de arjs -->
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <style>
    html,body{margin:0;height:100%;background:transparent;overflow:hidden;}
    /* HUD / Loader simples */
    #hud{
      position:fixed;left:0;top:0;right:0;padding:8px 12px;
      font:13px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.8);
      display:flex;justify-content:space-between;gap:8px;align-items:center;
      pointer-events:none; z-index:10;
    }
    #status{opacity:.9}
    #debug{pointer-events:auto;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.2);
      padding:4px 8px;border-radius:6px;cursor:pointer}
    #panel{
      position:fixed;left:8px;bottom:8px;right:8px;
      background:rgba(0,0,0,.6);color:#fff;padding:8px;border-radius:8px;
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      display:none;max-height:35vh;overflow:auto;white-space:pre-wrap; z-index:10;
    }

    /* CHANGE: liberar gestos de toque no canvas para que taps virem eventos imediatamente */
    a-scene, canvas { touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <!-- Loader/HUD (MindAR não remove automático como o .arjs-loader) -->
  <div id="hud">
    <div id="status">Carregando…</div>
    <button id="debug" aria-pressed="false">Debug</button>
  </div>
  <div id="panel" aria-hidden="true"></div>

  <!-- SCENE: MindAR em vez de AR.js -->
  <a-scene
    mindar-image="imageTargetSrc: assets/target.mind; filterMinCF: 0.001; filterBeta: 0.02;"
    vr-mode-ui="enabled: false"
    renderer="colorManagement: true; physicallyCorrectLights: true; alpha: true; antialias: true"
    embedded
    device-orientation-permission-ui="enabled: true">

    <a-assets timeout="20000">
      <!-- mantenha os nomes/pastas exatamente como no GitHub (case-sensitive) -->
      <img id="firstFrame" src="assets/Anim1/anim1_0001.png" crossorigin="anonymous"/>
    </a-assets>

    <!-- Câmera + cursor p/ clique em objetos 3D -->
    <a-camera position="0 0 0"
              look-controls="enabled: false"
              cursor="rayOrigin: mouse; fuse: false"
              raycaster="objects: .btn; far: 20;"></a-camera>

    <!-- CHANGE: âncora MindAR no lugar de <a-marker> -->
    <a-entity mindar-image-target="targetIndex: 0" id="anchor">

      <!-- Sprite/Quad da animação -->
      <a-image id="sprite"
               src="#firstFrame"
               position="0 0 0"
               rotation="0 0 0"
               material="transparent: true; alphaTest: 0.01; side: double; opacity: 1"
               width="1.2" height="1.2"
               visible="false">
      </a-image>

      <!-- Botões 3D declarativos -->
      <a-entity id="buttons" visible="false" position="0 0.05 0" rotation="0 0 0">
        <a-plane class="btn" position="-0.5 0 0" width="0.4" height="0.15" color="#222" opacity="0.9"
                 hover-color="over:#444; out:#222"
                 click-open-url="url:https://randobando.tv/">
          <a-text value="randobando.tv" align="center" width="1.2" position="0 0 0.01"></a-text>
        </a-plane>

        <a-plane class="btn" position="0 0 0" width="0.4" height="0.15" color="#222" opacity="0.9"
                 hover-color="over:#444; out:#222"
                 click-open-url="url:https://www.instagram.com/randobando.tv/">
          <a-text value="instagram" align="center" width="1.2" position="0 0 0.01"></a-text>
        </a-plane>

        <a-plane class="btn" position="0.5 0 0" width="0.4" height="0.15" color="#222" opacity="0.9"
                 hover-color="over:#444; out:#222"
                 click-open-url="url:https://www.behance.net/randobando">
          <a-text value="behance" align="center" width="1.2" position="0 0 0.01"></a-text>
        </a-plane>
      </a-entity>

    </a-entity>
  </a-scene>

  <script>
    // ============= COMPONENTES (botões) =============
    // CHANGE: substituir redirecionamentos “automáticos” por clique do usuário (mais confiável no iOS)
    AFRAME.registerComponent('click-open-url', {
      schema: { url: {type: 'string'} },
      init(){
        this.onClick = (e) => {
          e.stopPropagation();
          const a = document.createElement('a');
          a.href = this.data.url;
          a.target = '_blank';
          a.rel = 'noopener';
          document.body.appendChild(a);
          a.click();
          a.remove();
        };
        this.el.addEventListener('click', this.onClick);
      },
      remove(){
        this.el.removeEventListener('click', this.onClick);
      }
    });

    AFRAME.registerComponent('hover-color', {
      schema: { over: {default:'#444'}, out:{default:'#222'} },
      init(){
        this.onEnter = () => this.el.setAttribute('color', this.data.over);
        this.onLeave = () => this.el.setAttribute('color', this.data.out);
        this.el.addEventListener('mouseenter', this.onEnter);
        this.el.addEventListener('mouseleave', this.onLeave);
      },
      remove(){
        this.el.removeEventListener('mouseenter', this.onEnter);
        this.el.removeEventListener('mouseleave', this.onLeave);
      }
    });

    // ============= DEBUG UI =============
    const log = (...args)=>{ console.log(...args); addPanel(args.map(String).join(' ')); }
    const panel = document.getElementById('panel');
    const statusEl = document.getElementById('status');
    document.getElementById('debug').addEventListener('click', (e)=>{
      const on = panel.style.display !== 'block';
      panel.style.display = on ? 'block' : 'none';
      e.currentTarget.setAttribute('aria-pressed', String(on));
      panel.setAttribute('aria-hidden', String(!on));
    });
    function addPanel(s){ panel.textContent += s + "\n"; }

    // ============= SEQUÊNCIAS (spritesheet em PNGs) =============
    const ANIM1 = {
      folder: 'assets/Anim1',
      pattern: i => `anim1_${String(i).padStart(4,'0')}.png`,
      start: 1, end: 6, fps: 10
    };
    const KEEP = {
      folder: 'assets/Keepalive',
      pattern: i => `keep_${String(i).padStart(4,'0')}.png`,
      start: 1, end: 6, fps: 6, loop: true
    };

    let detected = false, playing = false, keepAlive = false;
    let frameTimer = null, currentFrame = 1, currentAnim = null;

    const $ = sel => document.querySelector(sel);
    const sprite = $('#sprite');
    const buttons = $('#buttons');
    const anchor = document.getElementById('anchor');

    async function preloadSequence(cfg){
      const results = [];
      for (let i = cfg.start; i <= cfg.end; i++){
        const url = `${cfg.folder}/${cfg.pattern(i)}?v=2`;
        results.push(new Promise((resolve)=>{
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = ()=>{ log('preload OK', url); resolve({url, ok:true}); };
          img.onerror = ()=>{ log('preload ERROR', url); resolve({url, ok:false}); };
          img.src = url;
        }));
      }
      const out = await Promise.all(results);
      const ok = out.filter(r=>r.ok).length;
      const ko = out.length - ok;
      log(`preload done: OK=${ok} ERR=${ko}`);
      return out;
    }

    function playSequence(cfg, onEnd){
      stopSequence();
      currentAnim = cfg; currentFrame = cfg.start;
      const interval = 1000 / (cfg.fps || 10);
      frameTimer = setInterval(() => {
        const src = `${cfg.folder}/${cfg.pattern(currentFrame)}?v=2`;
        sprite.setAttribute('src', src);
        currentFrame++;
        if (currentFrame > cfg.end){
          if (cfg.loop){ currentFrame = cfg.start; }
          else { stopSequence(); if (onEnd) onEnd(); }
        }
      }, interval);
    }
    function stopSequence(){
      if (frameTimer){ clearInterval(frameTimer); frameTimer = null; }
    }

    // ============= EVENTOS (MindAR) =============
    // CHANGE: markerFound/markerLost -> targetFound/targetLost, escutando no âncora
    anchor.addEventListener('targetFound', async () => {
      detected = true;
      statusEl.textContent = 'Alvo detectado';
      sprite.setAttribute('visible', 'true');
      buttons.setAttribute('visible', 'false');
      keepAlive = false; playing = false;

      // pré-carrega as duas sequências
      const p1 = await preloadSequence(ANIM1);
      const p2 = await preloadSequence(KEEP);
      if (!p1.some(r=>r.ok)){
        log('ATENÇÃO: nenhum frame de ANIM1 foi carregado. Verifique o caminho/case.');
      }
      if (!p2.some(r=>r.ok)){
        log('ATENÇÃO: nenhum frame de KEEP foi carregado. Verifique o caminho/case.');
      }
    });

    anchor.addEventListener('targetLost', () => {
      detected = false;
      statusEl.textContent = 'Procurando alvo...';
      sprite.setAttribute('visible', 'false');
      buttons.setAttribute('visible', 'false');
      stopSequence();
      keepAlive = false; playing = false;
    });

    // ============= TAP HANDLER (mobile/desktop confiável) =============
    // CHANGE: ouvir taps diretamente no canvas da cena
    function handleUserTap(){
      if (!detected || playing || keepAlive) return;
      playing = true;
      playSequence(ANIM1, () => {
        keepAlive = true; playing = false;
        playSequence(KEEP);
        buttons.setAttribute('visible', 'true');
      });
    }

    const scene = document.querySelector('a-scene');
    scene.addEventListener('loaded', () => {
      const cv = scene.canvas;
      if (!cv) { log('canvas ainda não disponível'); return; }
      ['pointerdown','touchstart','click'].forEach(ev=>{
        cv.addEventListener(ev, () => handleUserTap(), {passive:true});
      });
      log('Tap handlers ativos no canvas:', 'pointerdown/touchstart/click');
      statusEl.textContent = 'Aponte para o alvo';
    });

    // Log de erros
    window.addEventListener('error', (e)=>{ log('window error:', e.message); });
  </script>
</body>
</html>
