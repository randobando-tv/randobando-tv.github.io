<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>RANDO_AR — MindAR com Botão de Início</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <!-- MindAR (A-Frame integration) -->
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <style>
    html,body{margin:0;height:100%;background:transparent;overflow:hidden;}
    a-scene, canvas { touch-action: manipulation; -webkit-tap-highlight-color: transparent; }

    /* HUD / DEBUG */
    #hud{
      position:fixed;left:0;top:0;right:0;padding:8px 12px;
      font:13px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.8);
      display:flex;justify-content:space-between;gap:8px;align-items:center;
      pointer-events:none; z-index:10;
    }
    #status{opacity:.9}
    #debug{pointer-events:auto;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.2);
      padding:4px 8px;border-radius:6px;cursor:pointer}
    #panel{
      position:fixed;left:8px;bottom:8px;right:8px;
      background:rgba(0,0,0,.6);color:#fff;padding:8px;border-radius:8px;
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      display:none;max-height:35vh;overflow:auto;white-space:pre-wrap; z-index:10;
    }

    /* Botão de início (overlay DOM) */
    #startBtn{
      position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
      z-index:12; pointer-events:auto;
      border-radius:999px; padding:12px 18px; font:600 16px/1.2 system-ui, sans-serif;
      background:#111; color:#fff; border:1px solid rgba(255,255,255,.3); opacity:.95;
      box-shadow:0 6px 20px rgba(0,0,0,.35); cursor:pointer;
      display:none;
    }
    #startBtn:active{ transform:translateX(-50%) scale(.98); }
  </style>
</head>
<body>
  <div id="hud">
    <div id="status">Carregando…</div>
    <button id="debug" aria-pressed="false">Debug</button>
  </div>
  <div id="panel" aria-hidden="true"></div>
  <button id="startBtn">▶ Iniciar animação</button>

  <a-scene
    mindar-image="imageTargetSrc: assets/target.mind; filterMinCF: 0.001; filterBeta: 0.02;"
    vr-mode-ui="enabled: false"
    renderer="colorManagement: true; physicallyCorrectLights: true; alpha: true; antialias: true"
    embedded
    device-orientation-permission-ui="enabled: true">

    <a-assets id="assets" timeout="20000">
      <!-- Primeiro frame: deixa algo pronto na tela enquanto pré-carrega -->
      <img id="firstFrame" src="assets/Anim1/anim1_0001.png" crossorigin="anonymous"/>
    </a-assets>

    <a-camera position="0 0 0"
              look-controls="enabled: false"
              cursor="rayOrigin: mouse; fuse: false"
              raycaster="objects: .btn; far: 20;"></a-camera>

    <a-entity mindar-image-target="targetIndex: 0" id="anchor">
      <!-- a-image é conveniente; vamos trocar material.src por IDs de assets -->
      <!-- IMPORTANTE: class="clickthrough" remove este elemento da detecção do raycaster -->
      <a-image id="sprite"
               src="#firstFrame"
               position="0 0 0"
               material="transparent: true; alphaTest: 0.01; side: double; opacity: 1"
               width="1.2" height="1.2"
               visible="false"
               class="clickthrough">
      </a-image>

      <!-- Botões com position Z maior (0.1) para ficarem na frente do sprite (0) -->
      <a-entity id="buttons" visible="false" position="0 0.05 0.1" rotation="0 0 0">
        <!-- BOTÕES ORIGINAIS -->
        <a-plane id="btn-original-1" class="btn" position="0.5 0.2 0.1" width="0.4" height="0.15" color="#222" opacity="0.9"
                 hover-color="over:#444; out:#222"
                 click-open-url="url:https://randobando.tv/">
          <a-text value="randobando.tv" align="center" width="1.2" position="0 0 0.01"></a-text>
        </a-plane>

        <a-plane id="btn-original-2" class="btn" position="0.5 0 0.1" width="0.4" height="0.15" color="#222" opacity="0.9"
                 hover-color="over:#444; out:#222"
                 click-open-url="url:https://www.instagram.com/randobando.tv/">
          <a-text value="instagram" align="center" width="1.2" position="0 0 0.01"></a-text>
        </a-plane>

        <a-plane id="btn-original-3" class="btn" position="0.5 -0.2 0.1" width="0.4" height="0.15" color="#222" opacity="0.9"
                 hover-color="over:#444; out:#222"
                 click-open-url="url:https://www.behance.net/randobando">
          <a-text value="behance" align="center" width="1.2" position="0 0 0.01"></a-text>
        </a-plane>
      </a-entity>
    </a-entity>
  </a-scene>

  <script>
    // ===== Helpers de UI/Debug =====
    const log = (...args)=>{ console.log(...args); addPanel(args.map(String).join(' ')); }
    const panel = document.getElementById('panel');
    const statusEl = document.getElementById('status');
    document.getElementById('debug').addEventListener('click', (e)=>{
      const on = panel.style.display !== 'block';
      panel.style.display = on ? 'block' : 'none';
      e.currentTarget.setAttribute('aria-pressed', String(on));
      panel.setAttribute('aria-hidden', String(!on));
    });
    function addPanel(s){ panel.textContent += s + "\n"; }

    // ===== Sequências (vamos usar IDs dentro do <a-assets>) =====
    const ANIM1 = {
      name: 'anim1', folder: 'assets/Anim1',
      pattern: i => `anim1_${String(i).padStart(4,'0')}.png`,
      start: 1, end: 6, fps: 10, ids: []
    };
    const KEEP = {
      name: 'keep', folder: 'assets/Keepalive',
      pattern: i => `keep_${String(i).padStart(4,'0')}.png`,
      start: 1, end: 6, fps: 6, loop: true, ids: []
    };

    const assetsEl = document.getElementById('assets');
    const sprite = document.getElementById('sprite');
    const buttons = document.getElementById('buttons');
    const startBtn = document.getElementById('startBtn');
    const anchor = document.getElementById('anchor');

    let detected = false, playing = false, keepAlive = false;
    let timerId = null, currentFrame = 1, currentCfg = null;

    function ensureAssetImg(id, src){
      let el = document.getElementById(id);
      if (!el){
        el = document.createElement('img');
        el.setAttribute('id', id);
        el.setAttribute('src', src);
        el.setAttribute('crossorigin', 'anonymous');
        assetsEl.appendChild(el);
      }
      return el;
    }

    async function preloadSequence(cfg){
      const ids = [];
      const promises = [];
      for (let i = cfg.start; i <= cfg.end; i++){
        const id = `${cfg.name}_${String(i).padStart(4,'0')}`;
        const src = `${cfg.folder}/${cfg.pattern(i)}`;
        const img = ensureAssetImg(id, src);
        ids.push(id);
        if (!img.complete){
          promises.push(new Promise(res=>{
            img.addEventListener('load', res, {once:true});
            img.addEventListener('error', res, {once:true});
          }));
        }
      }
      await Promise.all(promises);
      cfg.ids = ids;
      log(`preload ${cfg.name}: ${ids.length} frames prontos`);
      return ids.length;
    }

    function setSpriteById(assetId){
      const ref = `#${assetId}`;
      // definir nos dois lugares para forçar atualização do material
      sprite.setAttribute('src', ref);
      sprite.setAttribute('material', 'src', ref);
    }

    function stopSequence(){
      if (timerId){ clearTimeout(timerId); timerId = null; }
    }

    function playSequence(cfg, onEnd){
      stopSequence();
      currentCfg = cfg;
      currentFrame = cfg.start;
      const interval = 1000 / (cfg.fps || 10);

      const step = () => {
        const idx = currentFrame - cfg.start;               // 0-based
        const assetId = cfg.ids[idx];
        if (assetId){ setSpriteById(assetId); }
        currentFrame++;
        if (currentFrame > cfg.end){
          if (cfg.loop){ currentFrame = cfg.start; timerId = setTimeout(step, interval); }
          else { stopSequence(); onEnd && onEnd(); }
        } else {
          timerId = setTimeout(step, interval);
        }
      };
      step();
    }

    async function startAnimationFlow(){
      if (!detected || playing || keepAlive) return;
      playing = true;
      startBtn.style.display = 'none';

      // garante assets carregados
      await preloadSequence(ANIM1);
      await preloadSequence(KEEP);

      sprite.setAttribute('visible', 'true');

      playSequence(ANIM1, () => {
        keepAlive = true; playing = false;
        playSequence(KEEP);
        buttons.setAttribute('visible', 'true');
        log('Botões agora visíveis!');
      });
    }

    // Eventos MindAR
    anchor.addEventListener('targetFound', () => {
      detected = true;
      statusEl.textContent = 'Alvo detectado — toque em "Iniciar animação".';
      sprite.setAttribute('visible', 'true');   // mostra o primeiro frame
      buttons.setAttribute('visible', 'false');
      keepAlive = false; playing = false;
      startBtn.style.display = 'inline-block';  // mostra botão de início
    });

    anchor.addEventListener('targetLost', () => {
      detected = false;
      statusEl.textContent = 'Procurando alvo...';
      sprite.setAttribute('visible', 'false');
      buttons.setAttribute('visible', 'false');
      startBtn.style.display = 'none';
      stopSequence();
      keepAlive = false; playing = false;
    });

    // Clique no botão (gesto explícito do usuário)
    startBtn.addEventListener('click', startAnimationFlow);

    // Fallback: tap no canvas também inicia
    const scene = document.querySelector('a-scene');
    scene.addEventListener('loaded', () => {
      const cv = scene.canvas;
      if (cv){
        ['pointerdown','touchstart','click'].forEach(ev=>{
          cv.addEventListener(ev, () => startAnimationFlow(), {passive:true});
        });
        log('Tap handlers no canvas prontos (pointerdown/touchstart/click)');
      }
      statusEl.textContent = 'Aponte para o alvo';
    });

    // Componentes de botão 3D
    AFRAME.registerComponent('click-open-url', {
      schema: { url: {type: 'string'} },
      init(){
        log(`[click-open-url] Componente inicializado para URL: ${this.data.url}`);
      }
    });

    AFRAME.registerComponent('hover-color', {
      schema: { over: {default:'#444'}, out:{default:'#222'} },
      init(){
        this.onEnter = () => this.el.setAttribute('color', this.data.over);
        this.onLeave = () => this.el.setAttribute('color', this.data.out);
        this.el.addEventListener('mouseenter', this.onEnter);
        this.el.addEventListener('mouseleave', this.onLeave);
      },
      remove(){
        this.el.removeEventListener('mouseenter', this.onEnter);
        this.el.removeEventListener('mouseleave', this.onLeave);
      }
    });

    // ===== SISTEMA DE DETECÇÃO MANUAL DE CLIQUES =====
    // Como o raycaster do A-Frame não está funcionando com MindAR, vamos usar Three.js diretamente
    
    let manualRaycaster = null;
    let mouse = new THREE.Vector2();
    
    function setupManualClickDetection() {
      const scene = document.querySelector('a-scene');
      if (!scene || !scene.hasLoaded) {
        setTimeout(setupManualClickDetection, 500);
        return;
      }
      
      const sceneEl = scene;
      const camera = sceneEl.camera;
      const canvas = sceneEl.canvas;
      
      if (!camera || !canvas) {
        log('[Manual Click] Câmera ou canvas não encontrados, tentando novamente...');
        setTimeout(setupManualClickDetection, 500);
        return;
      }
      
      manualRaycaster = new THREE.Raycaster();
      log('[Manual Click] Sistema de detecção manual inicializado');
      
      // Função para processar clique/toque
      function handleInteraction(event) {
        // Obter coordenadas normalizadas do clique/toque
        let clientX, clientY;
        if (event.touches && event.touches.length > 0) {
          clientX = event.touches[0].clientX;
          clientY = event.touches[0].clientY;
        } else if (event.changedTouches && event.changedTouches.length > 0) {
          clientX = event.changedTouches[0].clientX;
          clientY = event.changedTouches[0].clientY;
        } else {
          clientX = event.clientX;
          clientY = event.clientY;
        }
        
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        
        // Configurar raycaster
        manualRaycaster.setFromCamera(mouse, camera);
        
        // Obter todos os objetos 3D dos botões
        const buttonElements = document.querySelectorAll('.btn');
        const buttonMeshes = [];
        
        buttonElements.forEach(btnEl => {
          const mesh = btnEl.getObject3D('mesh');
          if (mesh && btnEl.getAttribute('visible') !== 'false') {
            mesh.userData.element = btnEl;
            buttonMeshes.push(mesh);
          }
        });
        
        // Verificar intersecções
        const intersects = manualRaycaster.intersectObjects(buttonMeshes, true);
        
        if (intersects.length > 0) {
          // Encontrar o elemento A-Frame correspondente
          let targetEl = null;
          let currentObj = intersects[0].object;
          
          while (currentObj && !targetEl) {
            if (currentObj.el && currentObj.el.classList.contains('btn')) {
              targetEl = currentObj.el;
              break;
            }
            if (currentObj.userData && currentObj.userData.element) {
              targetEl = currentObj.userData.element;
              break;
            }
            currentObj = currentObj.parent;
          }
          
          if (targetEl) {
            log(`[Manual Click] Botão clicado: ${targetEl.id || 'sem ID'}`);
            
            // Tentar obter URL do componente A-Frame
            let url = null;
            if (targetEl.components['click-open-url']) {
              url = targetEl.components['click-open-url'].data.url;
            }
            
            if (url) {
              log(`[Manual Click] Abrindo URL: ${url}`);
              
              // Tentar abrir o link
              try {
                const newWindow = window.open(url, '_blank', 'noopener,noreferrer');
                if (newWindow) {
                  newWindow.opener = null;
                  log(`[Manual Click] Link aberto com sucesso!`);
                } else {
                  log(`[Manual Click] window.open bloqueado, tentando método alternativo...`);
                  // Método alternativo: criar elemento <a> e simular clique
                  const a = document.createElement('a');
                  a.href = url;
                  a.target = '_blank';
                  a.rel = 'noopener noreferrer';
                  a.style.display = 'none';
                  document.body.appendChild(a);
                  
                  const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                  });
                  a.dispatchEvent(clickEvent);
                  
                  setTimeout(() => a.remove(), 100);
                  log(`[Manual Click] Método alternativo executado`);
                }
              } catch (err) {
                log(`[Manual Click] Erro: ${err.message}`);
              }
            }
          }
        }
      }
      
      // Adicionar listeners
      canvas.addEventListener('click', handleInteraction);
      canvas.addEventListener('touchend', handleInteraction);
      
      log('[Manual Click] Listeners adicionados ao canvas');
    }
    
    // Iniciar após a cena carregar
    document.addEventListener('DOMContentLoaded', () => {
      const scene = document.querySelector('a-scene');
      if (scene.hasLoaded) {
        setupManualClickDetection();
      } else {
        scene.addEventListener('loaded', setupManualClickDetection);
      }
    });

    // Log de erros
    window.addEventListener('error', (e)=>{ log('window error:', e.message); });
  </script>
</body>
</html>