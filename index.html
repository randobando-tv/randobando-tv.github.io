<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>RANDO_AR ‚Äî MindAR com Bot√£o de In√≠cio</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <!-- MindAR (A-Frame integration) -->
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <style>
    html,body{margin:0;height:100%;background:transparent;overflow:hidden;}
    a-scene, canvas { touch-action: manipulation; -webkit-tap-highlight-color: transparent; }

    /* HUD / DEBUG */
    #hud{
      position:fixed;left:0;top:0;right:0;padding:8px 12px;
      font:13px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.8);
      display:flex;justify-content:space-between;gap:8px;align-items:center;
      pointer-events:none; z-index:10;
    }
    #status{opacity:.9}
    #debug{pointer-events:auto;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.2);
      padding:4px 8px;border-radius:6px;cursor:pointer}
    #panel{
      position:fixed;left:8px;bottom:8px;right:8px;
      background:rgba(0,0,0,.6);color:#fff;padding:8px;border-radius:8px;
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      display:none;max-height:35vh;overflow:auto;white-space:pre-wrap; z-index:10;
    }

    /* Bot√£o de in√≠cio (overlay DOM) */
    #startBtn{
      position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
      z-index:12; pointer-events:auto;
      border-radius:999px; padding:12px 18px; font:600 16px/1.2 system-ui, sans-serif;
      background:#111; color:#fff; border:1px solid rgba(255,255,255,.3); opacity:.95;
      box-shadow:0 6px 20px rgba(0,0,0,.35); cursor:pointer;
      display:none;
    }
    #startBtn:active{ transform:translateX(-50%) scale(.98); }
  </style>
</head>
<body>
  <div id="hud">
    <div id="status">Carregando‚Ä¶</div>
    <button id="debug" aria-pressed="false">Debug</button>
  </div>
  <div id="panel" aria-hidden="true"></div>
  <button id="startBtn">‚ñ∂ Iniciar anima√ß√£o</button>

  <a-scene
    mindar-image="imageTargetSrc: assets/target.mind; filterMinCF: 0.001; filterBeta: 0.02;"
    vr-mode-ui="enabled: false"
    renderer="colorManagement: true; physicallyCorrectLights: true; alpha: true; antialias: true"
    embedded
    device-orientation-permission-ui="enabled: true">

    <a-assets id="assets" timeout="20000">
      <!-- Assets ser√£o carregados dinamicamente -->
    </a-assets>

    <a-camera position="0 0 0"
              look-controls="enabled: false"
              cursor="rayOrigin: mouse; fuse: false"
              raycaster="objects: .btn; far: 20;"></a-camera>

    <a-entity mindar-image-target="targetIndex: 0" id="anchor">
      <!-- Elementos ser√£o criados dinamicamente com base na configura√ß√£o -->
    </a-entity>
  </a-scene>

  <script>
    // ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    // ‚ïë                     üé® SE√á√ÉO DE CONFIGURA√á√ÉO                             ‚ïë
    // ‚ïë                                                                          ‚ïë
    // ‚ïë  Aqui voc√™ pode ajustar todos os elementos da cena AR de forma simples   ‚ïë
    // ‚ïë  e organizada. Modifique os valores abaixo para personalizar:           ‚ïë
    // ‚ïë  - Posi√ß√£o, tamanho e rota√ß√£o dos elementos                             ‚ïë
    // ‚ïë  - Sequ√™ncias de anima√ß√£o (pasta, frames, FPS)                          ‚ïë
    // ‚ïë  - Bot√µes (texto, cor, URL, posi√ß√£o)                                    ‚ïë
    // ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

    const CONFIG = {
      // ===== SPRITE / IMAGEM PRINCIPAL =====
      sprite: {
        position: { x: 0, y: 0, z: 0 },          // Posi√ß√£o no espa√ßo 3D
        rotation: { x: 0, y: 0, z: 0 },          // Rota√ß√£o em graus
        scale: { width: 1.2, height: 1.2 },      // Tamanho (largura x altura)
        material: {
          transparent: true,
          alphaTest: 0.01,
          side: 'double',
          opacity: 1
        },
        // Anima√ß√µes de movimento do sprite (opcional)
        motionAnimations: [
          // Exemplo: Mover para frente e para tr√°s continuamente
          {
            property: 'position',
            from: { x: 0, y: 0, z: 0 },       // Posi√ß√£o inicial (no alvo)
            to: { x: 1, y: 1, z: 0.4 },      // Move ligeiramente para tr√°s
            duration: 1500,                   // Dura√ß√£o de 1.5 segundos para ir
            easing: 'easeInOutQuad',          // Suaviza o in√≠cio e o fim
            delay: 0,
            loop: true,                       // Repete continuamente
            dir: 'alternate',                 // Alterna a dire√ß√£o (vai e volta)
            trigger: 'onKeepAlive'            // Inicia quando o keep alive aparece
          }
        ]
      },

      // ===== ANIMA√á√ïES =====
      animations: {
        // Primeira anima√ß√£o (toque para iniciar)
        anim1: {
          name: 'anim1',
          folder: 'assets/Anim1',
          pattern: i => `anim1_${String(i).padStart(4,'0')}.png`,
          start: 1,
          end: 6,
          fps: 10,
          loop: false
        },
        // Anima√ß√£o de "keep alive" (loop cont√≠nuo)
        keepAlive: {
          name: 'keep',
          folder: 'assets/Keepalive',
          pattern: i => `keep_${String(i).padStart(4,'0')}.png`,
          start: 1,
          end: 6,
          fps: 6,
          loop: true
        }
      },

      // ===== CONTAINER DE BOT√ïES =====
      buttonsContainer: {
        position: { x: 0, y: 0.05, z: 0.1 },     // Posi√ß√£o do grupo de bot√µes
        rotation: { x: 0, y: 0, z: 0 },          // Rota√ß√£o do grupo
        // Anima√ß√µes de movimento do container de bot√µes (opcional)
        motionAnimations: [
          // Exemplo: Bot√µes aparecem de baixo para cima
          // {
          //   property: 'position',
          //   from: { x: 0, y: -0.3, z: 0.1 },
          //   to: { x: 0, y: 0.05, z: 0.1 },
          //   duration: 800,
          //   easing: 'easeOutBack',
          //   delay: 0,
          //   loop: false,
          //   trigger: 'onKeepAlive'
          // }
        ]
      },

      // ===== BOT√ïES INDIVIDUAIS =====
      buttons: [
        {
          id: 'btn-1',
          text: 'randobando.tv',
          url: 'https://randobando.tv/',
          position: { x: -0.5, y: 0, z: 0 },
          size: { width: 0.4, height: 0.15 },
          colors: {
            default: '#222',
            hover: '#444'
          },
          textStyle: {
            align: 'center',
            width: 1.2,
            position: { x: 0, y: 0, z: 0.01 }
          },
          opacity: 0.9,
          // Anima√ß√µes de movimento individuais do bot√£o (opcional)
          motionAnimations: [
            // Exemplo: Bot√£o pulsa ao aparecer
            // {
            //   property: 'scale',
            //   from: { x: 0.5, y: 0.5, z: 1 },
            //   to: { x: 1, y: 1, z: 1 },
            //   duration: 400,
            //   easing: 'easeOutElastic',
            //   delay: 0,
            //   loop: false,
            //   trigger: 'onKeepAlive'
            // }
          ]
        },
        {
          id: 'btn-2',
          text: 'instagram',
          url: 'https://www.instagram.com/randobando.tv/',
          position: { x: 0, y: 0, z: 0 },
          size: { width: 0.4, height: 0.15 },
          colors: {
            default: '#222',
            hover: '#444'
          },
          textStyle: {
            align: 'center',
            width: 1.2,
            position: { x: 0, y: 0, z: 0.01 }
          },
          opacity: 0.9,
          motionAnimations: []
        },
        {
          id: 'btn-3',
          text: 'behance',
          url: 'https://www.behance.net/randobando',
          position: { x: 0.5, y: 0, z: 0 },
          size: { width: 0.4, height: 0.15 },
          colors: {
            default: '#222',
            hover: '#444'
          },
          textStyle: {
            align: 'center',
            width: 1.2,
            position: { x: 0, y: 0, z: 0.01 }
          },
          opacity: 0.9,
          motionAnimations: []
        }
      ]
    };

    // ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    // ‚ïë                     üîß C√ìDIGO DE FUNCIONAMENTO                           ‚ïë
    // ‚ïë                                                                          ‚ïë
    // ‚ïë  Daqui para baixo √© o c√≥digo que faz tudo funcionar.                    ‚ïë
    // ‚ïë  Voc√™ n√£o precisa modificar nada aqui, a menos que queira adicionar     ‚ïë
    // ‚ïë  funcionalidades avan√ßadas.                                             ‚ïë
    // ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

    // ===== Helpers de UI/Debug =====
    const log = (...args)=>{ console.log(...args); addPanel(args.map(String).join(' ')); }
    const panel = document.getElementById('panel');
    const statusEl = document.getElementById('status');
    document.getElementById('debug').addEventListener('click', (e)=>{
      const on = panel.style.display !== 'block';
      panel.style.display = on ? 'block' : 'none';
      e.currentTarget.setAttribute('aria-pressed', String(on));
      panel.setAttribute('aria-hidden', String(!on));
    });
    function addPanel(s){ panel.textContent += s + "\n"; }

    // ===== Vari√°veis Globais =====
    const assetsEl = document.getElementById('assets');
    const anchor = document.getElementById('anchor');
    const startBtn = document.getElementById('startBtn');
    
    let sprite, buttonsContainer;
    let detected = false, playing = false, keepAlive = false;
    let timerId = null, currentFrame = 1, currentCfg = null;

    // Adicionar IDs vazios para as anima√ß√µes
    CONFIG.animations.anim1.ids = [];
    CONFIG.animations.keepAlive.ids = [];

    // ===== Fun√ß√£o para criar elementos dinamicamente =====
    function createSceneElements() {
      // Criar sprite
      sprite = document.createElement('a-image');
      sprite.setAttribute('id', 'sprite');
      sprite.setAttribute('position', `${CONFIG.sprite.position.x} ${CONFIG.sprite.position.y} ${CONFIG.sprite.position.z}`);
      sprite.setAttribute('rotation', `${CONFIG.sprite.rotation.x} ${CONFIG.sprite.rotation.y} ${CONFIG.sprite.rotation.z}`);
      sprite.setAttribute('width', CONFIG.sprite.scale.width);
      sprite.setAttribute('height', CONFIG.sprite.scale.height);
      sprite.setAttribute('material', `transparent: ${CONFIG.sprite.material.transparent}; alphaTest: ${CONFIG.sprite.material.alphaTest}; side: ${CONFIG.sprite.material.side}; opacity: ${CONFIG.sprite.material.opacity}`);
      sprite.setAttribute('visible', 'false');
      sprite.setAttribute('class', 'clickthrough');
      anchor.appendChild(sprite);

      
      // Float motion (inicialmente desligado; ligaremos no keepAlive)
      sprite.setAttribute('float-motion', {
        enabled: false,
        ampX: 0.01, ampY: 0.015, ampZ: 0.008,
        speedX: 0.6, speedY: 0.7, speedZ: 0.5,
        offsetX: 0.0, offsetY: 1.0, offsetZ: 2.0
      });
// Criar container de bot√µes
      buttonsContainer = document.createElement('a-entity');
      buttonsContainer.setAttribute('id', 'buttons');
      buttonsContainer.setAttribute('position', `${CONFIG.buttonsContainer.position.x} ${CONFIG.buttonsContainer.position.y} ${CONFIG.buttonsContainer.position.z}`);
      buttonsContainer.setAttribute('rotation', `${CONFIG.buttonsContainer.rotation.x} ${CONFIG.buttonsContainer.rotation.y} ${CONFIG.buttonsContainer.rotation.z}`);
      buttonsContainer.setAttribute('visible', 'false');
      anchor.appendChild(buttonsContainer);

      
      // Float motion do grupo de bot√µes (inicialmente off)
      buttonsContainer.setAttribute('float-motion', {
        enabled: false,
        ampX: 0.006, ampY: 0.009, ampZ: 0.006,
        speedX: 0.45, speedY: 0.52, speedZ: 0.4,
        offsetX: 0.7, offsetY: 0.2, offsetZ: 1.6
      });
// Criar bot√µes
      CONFIG.buttons.forEach((btnCfg, i) => {
        const btn = document.createElement('a-plane');
        btn.setAttribute('id', btnCfg.id);
        btn.setAttribute('class', 'btn');
        btn.setAttribute('position', `${btnCfg.position.x} ${btnCfg.position.y} ${btnCfg.position.z}`);
        btn.setAttribute('width', btnCfg.size.width);
        btn.setAttribute('height', btnCfg.size.height);
        btn.setAttribute('color', btnCfg.colors.default);
        btn.setAttribute('opacity', btnCfg.opacity);
        btn.setAttribute('hover-color', `over:${btnCfg.colors.hover}; out:${btnCfg.colors.default}`);
        btn.setAttribute('click-open-url', `url:${btnCfg.url}`);

        
        // Float motion leve por bot√£o, com fase variada por √≠ndice
        btn.setAttribute('float-motion', {
          enabled: false,
          ampX: 0.003, ampY: 0.004, ampZ: 0.0,
          speedX: 0.9,  speedY: 1.1, speedZ: 0.0,
          offsetX: (i || 0) * 0.8, offsetY: (i || 0) * 1.1, offsetZ: 0.0
        });
// Criar texto do bot√£o
        const text = document.createElement('a-text');
        text.setAttribute('value', btnCfg.text);
        text.setAttribute('align', btnCfg.textStyle.align);
        text.setAttribute('width', btnCfg.textStyle.width);
        text.setAttribute('position', `${btnCfg.textStyle.position.x} ${btnCfg.textStyle.position.y} ${btnCfg.textStyle.position.z}`);
        btn.appendChild(text);

        buttonsContainer.appendChild(btn);
      });

      log('Elementos da cena criados dinamicamente com base na configura√ß√£o');
    }

    // ===== Fun√ß√£o para aplicar anima√ß√µes de movimento =====
    function applyMotionAnimations(element, animations, trigger) {
      if (!animations || animations.length === 0) return;
      
      animations.forEach((anim, index) => {
        if (anim.trigger !== trigger) return;
        
        const animId = `motion-anim-${Date.now()}-${index}`;
        const property = anim.property; // 'position', 'rotation', 'scale'
        const from = anim.from;
        const to = anim.to;
        const duration = anim.duration || 1000;
        const easing = anim.easing || 'linear';
        const delay = anim.delay || 0;
        const loop = anim.loop || false;
        
        // Se tem valor 'from', definir antes de animar
        if (from) {
          if (property === 'position') {
            element.setAttribute('position', `${from.x} ${from.y} ${from.z}`);
          } else if (property === 'rotation') {
            element.setAttribute('rotation', `${from.x} ${from.y} ${from.z}`);
          } else if (property === 'scale') {
            element.setAttribute('scale', `${from.x} ${from.y} ${from.z}`);
          }
        }
        
        // Aplicar anima√ß√£o
        setTimeout(() => {
          const animConfig = {
            property: property,
            to: to,
            dur: duration,
            easing: easing,
            loop: loop
          };
          
          element.setAttribute(`animation__${animId}`, animConfig);
          log(`[Motion] Anima√ß√£o aplicada: ${property} em ${element.id || element.tagName}`);
        }, delay);
      });
    }

    // ===== Fun√ß√µes de gerenciamento de assets =====
    function ensureAssetImg(id, src){
      let el = document.getElementById(id);
      if (!el){
        el = document.createElement('img');
        el.setAttribute('id', id);
        el.setAttribute('src', src);
        el.setAttribute('crossorigin', 'anonymous');
        assetsEl.appendChild(el);
      }
      return el;
    }

    async function preloadSequence(cfg){
      const ids = [];
      const promises = [];
      for (let i = cfg.start; i <= cfg.end; i++){
        const id = `${cfg.name}_${String(i).padStart(4,'0')}`;
        const src = `${cfg.folder}/${cfg.pattern(i)}`;
        const img = ensureAssetImg(id, src);
        ids.push(id);
        if (!img.complete){
          promises.push(new Promise(res=>{
            img.addEventListener('load', res, {once:true});
            img.addEventListener('error', res, {once:true});
          }));
        }
      }
      await Promise.all(promises);
      cfg.ids = ids;
      log(`preload ${cfg.name}: ${ids.length} frames prontos`);
      return ids.length;
    }

    function setSpriteById(assetId){
      const ref = `#${assetId}`;
      sprite.setAttribute('src', ref);
      sprite.setAttribute('material', 'src', ref);
    }

    function stopSequence(){
      if (timerId){ clearTimeout(timerId); timerId = null; }
    }

    function playSequence(cfg, onEnd){
      stopSequence();
      currentCfg = cfg;
      currentFrame = cfg.start;
      const interval = 1000 / (cfg.fps || 10);

      const step = () => {
        const idx = currentFrame - cfg.start;
        const assetId = cfg.ids[idx];
        if (assetId){ setSpriteById(assetId); }
        currentFrame++;
        if (currentFrame > cfg.end){
          if (cfg.loop){ currentFrame = cfg.start; timerId = setTimeout(step, interval); }
          else { stopSequence(); onEnd && onEnd(); }
        } else {
          timerId = setTimeout(step, interval);
        }
      };
      step();
    }

    async function startAnimationFlow(){
      if (!detected || playing || keepAlive) return;
      playing = true;
      startBtn.style.display = 'none';

      // Garantir assets carregados
      await preloadSequence(CONFIG.animations.anim1);
      await preloadSequence(CONFIG.animations.keepAlive);

      sprite.setAttribute('visible', 'true');
      
      // Aplicar anima√ß√µes de movimento com trigger 'onAnimationStart'
      applyMotionAnimations(sprite, CONFIG.sprite.motionAnimations, 'onAnimationStart');

      playSequence(CONFIG.animations.anim1, () => {
        keepAlive = true; playing = false;
        playSequence(CONFIG.animations.keepAlive);
        buttonsContainer.setAttribute('visible', 'true');
        log('Bot√µes agora vis√≠veis!');
        
        
        // Ativar flutua√ß√£o suave
        sprite.setAttribute('float-motion', 'enabled', true);
        buttonsContainer.setAttribute('float-motion', 'enabled', true);
        CONFIG.buttons.forEach((btnCfg) => {
          const el = document.getElementById(btnCfg.id);
          if (el) el.setAttribute('float-motion', 'enabled', true);
        });
// Aplicar anima√ß√µes de movimento com trigger 'onKeepAlive'
        applyMotionAnimations(sprite, CONFIG.sprite.motionAnimations, 'onKeepAlive');
        applyMotionAnimations(buttonsContainer, CONFIG.buttonsContainer.motionAnimations, 'onKeepAlive');
        
        // Aplicar anima√ß√µes individuais aos bot√µes
        CONFIG.buttons.forEach((btnCfg, index) => {
          const btnElement = document.getElementById(btnCfg.id);
          if (btnElement && btnCfg.motionAnimations) {
            applyMotionAnimations(btnElement, btnCfg.motionAnimations, 'onKeepAlive');
          }
        });
      });
    }

    // ===== Eventos MindAR =====
    anchor.addEventListener('targetFound', () => {
      detected = true;
      statusEl.textContent = 'Alvo detectado ‚Äî toque em "Iniciar anima√ß√£o".';
      sprite.setAttribute('visible', 'true');
      buttonsContainer.setAttribute('visible', 'false');
      keepAlive = false; playing = false;
      startBtn.style.display = 'inline-block';
      
      // Aplicar anima√ß√µes de movimento com trigger 'onTargetFound'
      applyMotionAnimations(sprite, CONFIG.sprite.motionAnimations, 'onTargetFound');
    });

    anchor.addEventListener('targetLost', () => {
detected = false;
      statusEl.textContent = 'Procurando alvo...';
      sprite.setAttribute('visible', 'false');
      buttonsContainer.setAttribute('visible', 'false');
      startBtn.style.display = 'none';
      // Desativar flutua√ß√£o
      sprite.setAttribute('float-motion', 'enabled', false);
      buttonsContainer.setAttribute('float-motion', 'enabled', false);
      CONFIG.buttons.forEach((btnCfg) => {
        const el = document.getElementById(btnCfg.id);
        if (el) el.setAttribute('float-motion', 'enabled', false);
      });
      stopSequence();
      keepAlive = false; playing = false;
    });

    // ===== Inicializa√ß√£o =====
    startBtn.addEventListener('click', startAnimationFlow);

    const scene = document.querySelector('a-scene');
    scene.addEventListener('loaded', () => {
      // Criar elementos da cena
      createSceneElements();

      // Pr√©-carregar primeiro frame
      const firstFrameId = `${CONFIG.animations.anim1.name}_${String(CONFIG.animations.anim1.start).padStart(4,'0')}`;
      const firstFrameSrc = `${CONFIG.animations.anim1.folder}/${CONFIG.animations.anim1.pattern(CONFIG.animations.anim1.start)}`;
      ensureAssetImg(firstFrameId, firstFrameSrc);
      setSpriteById(firstFrameId);

      // Tap no canvas tamb√©m inicia
      const cv = scene.canvas;
      if (cv){
        ['pointerdown','touchstart','click'].forEach(ev=>{
          cv.addEventListener(ev, () => startAnimationFlow(), {passive:true});
        });
        log('Tap handlers no canvas prontos');
      }
      statusEl.textContent = 'Aponte para o alvo';

      // Iniciar sistema de detec√ß√£o manual de cliques
      setupManualClickDetection();
    });

    // ===== Componentes A-Frame =====
    AFRAME.registerComponent('click-open-url', {
      schema: { url: {type: 'string'} },
      init(){
        log(`[click-open-url] Componente inicializado para URL: ${this.data.url}`);
      }
    });

    AFRAME.registerComponent('hover-color', {
      schema: { over: {default:'#444'}, out:{default:'#222'} },
      init(){
        this.onEnter = () => this.el.setAttribute('color', this.data.over);
        this.onLeave = () => this.el.setAttribute('color', this.data.out);
        this.el.addEventListener('mouseenter', this.onEnter);
        this.el.addEventListener('mouseleave', this.onLeave);
      },
      remove(){
        this.el.removeEventListener('mouseenter', this.onEnter);
        this.el.removeEventListener('mouseleave', this.onLeave);
      }
    });

    // ===== Sistema de Detec√ß√£o Manual de Cliques =====
    let manualRaycaster = null;
    let mouse = new THREE.Vector2();
    
    function setupManualClickDetection() {
      const sceneEl = scene;
      const camera = sceneEl.camera;
      const canvas = sceneEl.canvas;
      
      if (!camera || !canvas) {
        log('[Manual Click] C√¢mera ou canvas n√£o encontrados, tentando novamente...');
        setTimeout(setupManualClickDetection, 500);
        return;
      }
      
      manualRaycaster = new THREE.Raycaster();
      log('[Manual Click] Sistema de detec√ß√£o manual inicializado');
      
      function handleInteraction(event) {
        let clientX, clientY;
        if (event.touches && event.touches.length > 0) {
          clientX = event.touches[0].clientX;
          clientY = event.touches[0].clientY;
        } else if (event.changedTouches && event.changedTouches.length > 0) {
          clientX = event.changedTouches[0].clientX;
          clientY = event.changedTouches[0].clientY;
        } else {
          clientX = event.clientX;
          clientY = event.clientY;
        }
        
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        
        manualRaycaster.setFromCamera(mouse, camera);
        
        const buttonElements = document.querySelectorAll('.btn');
        const buttonMeshes = [];
        
        buttonElements.forEach(btnEl => {
          const mesh = btnEl.getObject3D('mesh');
          if (mesh && btnEl.getAttribute('visible') !== 'false') {
            mesh.userData.element = btnEl;
            buttonMeshes.push(mesh);
          }
        });
        
        const intersects = manualRaycaster.intersectObjects(buttonMeshes, true);
        
        if (intersects.length > 0) {
          let targetEl = null;
          let currentObj = intersects[0].object;
          
          while (currentObj && !targetEl) {
            if (currentObj.el && currentObj.el.classList.contains('btn')) {
              targetEl = currentObj.el;
              break;
            }
            if (currentObj.userData && currentObj.userData.element) {
              targetEl = currentObj.userData.element;
              break;
            }
            currentObj = currentObj.parent;
          }
          
          if (targetEl) {
            log(`[Manual Click] Bot√£o clicado: ${targetEl.id}`);
            
            let url = null;
            if (targetEl.components['click-open-url']) {
              url = targetEl.components['click-open-url'].data.url;
            }
            
            if (url) {
              log(`[Manual Click] Abrindo URL: ${url}`);
              
              try {
                const newWindow = window.open(url, '_blank', 'noopener,noreferrer');
                if (newWindow) {
                  newWindow.opener = null;
                  log(`[Manual Click] Link aberto com sucesso!`);
                } else {
                  log(`[Manual Click] window.open bloqueado, tentando m√©todo alternativo...`);
                  const a = document.createElement('a');
                  a.href = url;
                  a.target = '_blank';
                  a.rel = 'noopener noreferrer';
                  a.style.display = 'none';
                  document.body.appendChild(a);
                  
                  const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                  });
                  a.dispatchEvent(clickEvent);
                  
                  setTimeout(() => a.remove(), 100);
                  log(`[Manual Click] M√©todo alternativo executado`);
                }
              } catch (err) {
                log(`[Manual Click] Erro: ${err.message}`);
              }
            }
          }
        }
      }
      
      canvas.addEventListener('click', handleInteraction);
      canvas.addEventListener('touchend', handleInteraction);
      
      log('[Manual Click] Listeners adicionados ao canvas');
    }

    window.addEventListener('error', (e)=>{ log('window error:', e.message); });
  </script>

<!-- Float motion component -->
<script>
AFRAME.registerComponent('float-motion', {
  schema: {
    ampX:   {default: 0.01},
    ampY:   {default: 0.015},
    ampZ:   {default: 0.008},
    speedX: {default: 0.6},
    speedY: {default: 0.7},
    speedZ: {default: 0.5},
    offsetX:{default: 0},
    offsetY:{default: 1.0},
    offsetZ:{default: 2.0},
    enabled:{default: true}
  },
  init () {
    this.base = new THREE.Vector3();
    this.ready = false;
    const setBase = () => {
      const p = this.el.object3D.position;
      this.base.set(p.x, p.y, p.z);
      this.ready = true;
    };
    if (this.el.object3D) setBase();
    this.el.addEventListener('loaded', setBase);
  },
  tick (time) {
    if (!this.ready || !this.data.enabled) return;
    const t = time / 1000;
    const d = this.data, b = this.base;
    this.el.object3D.position.set(
      b.x + d.ampX * Math.sin(t * d.speedX + d.offsetX),
      b.y + d.ampY * Math.sin(t * d.speedY + d.offsetY),
      b.z + d.ampZ * Math.sin(t * d.speedZ + d.offsetZ)
    );
  },
  resetBase () {
    const p = this.el.object3D.position;
    this.base.set(p.x, p.y, p.z);
  }
});
</script>

</body>
</html>